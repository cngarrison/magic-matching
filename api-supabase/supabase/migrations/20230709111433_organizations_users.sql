-- Custom types
CREATE TYPE public.app_permission AS enum (
    'organisations.admin',
    'organisations.read',
    'organisations.update',
    'organisations.delete',
    'users.admin',
    'users.update',
    'users.delete'
);
-- -- ALTER TYPE public.app_permission ADD VALUE 'users.admin';
-- ALTER TYPE public.app_permission ADD VALUE 'users.admin' BEFORE 'categories.create';
-- -- ALTER TYPE public.app_permission ADD VALUE 'users.admin' AFTER 'messages.delete';

CREATE TYPE public.app_role AS enum (
    'app.owner',
    'app.admin',
    'org.owner',
    'org.admin',
    'org.moderator',
    'user'
);

CREATE TYPE public.user_status AS enum (
    'NEW',
    'ACTIVE',
    'DISABLED'
);

--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--
CREATE TABLE public.users (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    auth_id uuid NOT NULL, -- UUID from auth.users - use this as public id for users
    username text,
    name_first text,
    name_last text,
    email text,
    user_data jsonb,
    status public.user_status DEFAULT 'NEW' ::public.user_status,
    avatar_url text,
    locale text,
    timezone text,
    --created_by bigint REFERENCES public.users NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone
);
CREATE INDEX idx_users_auth_id ON public.users(auth_id);

COMMENT ON TABLE public.users IS 'Profile data for each user.';

COMMENT ON COLUMN public.users.id IS 'Internal id for uniqueness and foreign keys, not public-facing id, use auth_id instead.';
COMMENT ON COLUMN public.users.auth_id IS 'References the internal Supabase Auth user - also used as public id for users.';

ALTER TABLE public.users OWNER TO postgres;


--
-- Name: organisations; Type: TABLE; Schema: public; Owner: postgres
--
CREATE TABLE public.organisations (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_id uuid DEFAULT extensions.uuid_generate_v4(),
    slug text NOT NULL,
    name text,
    email text,
    description text,
    org_data jsonb,
    --created_by bigint REFERENCES public.users NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone
);
CREATE INDEX idx_organisations_org_id ON public.organisations(org_id);

COMMENT ON TABLE public.organisations IS 'Data for each org, supports multi-tenancy.';

COMMENT ON COLUMN public.organisations.id IS 'Internal id for uniqueness and foreign keys, not public-facing id, use org_id instead.';
COMMENT ON COLUMN public.organisations.org_id IS 'Used as public id for organisations.';

ALTER TABLE public.organisations OWNER TO postgres;

CREATE TABLE public.organisation_users (
    organisation_id bigint NOT NULL,
    user_id bigint NOT NULL,
    is_primary_org boolean,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT organisation_users_pk PRIMARY KEY (organisation_id, user_id),
    CONSTRAINT organisation_users_user_fk FOREIGN KEY (user_id) REFERENCES public.users (id) ON DELETE CASCADE,
    CONSTRAINT organisation_users_organisation_fk FOREIGN KEY (organisation_id) REFERENCES public.organisations (id) ON DELETE CASCADE
);

COMMENT ON TABLE public.organisation_users IS 'Joining table for organisations and users.';

ALTER TABLE public.organisation_users OWNER TO postgres;



--
-- Name: user_roles; Type: TABLE; Schema: public; Owner: postgres
--
CREATE TABLE public.user_roles (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id bigint REFERENCES public.users ON DELETE CASCADE NOT NULL,
    role public.app_role NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE (user_id, role)
);

COMMENT ON TABLE public.user_roles IS 'Application roles for each user.';

ALTER TABLE public.user_roles OWNER TO postgres;

--
-- Name: role_permissions; Type: TABLE; Schema: public; Owner: postgres
--
CREATE TABLE public.role_permissions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role public.app_role NOT NULL,
    permission public.app_permission NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE (role, permission)
);

COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role.';

ALTER TABLE public.role_permissions OWNER TO postgres;


INSERT INTO public.role_permissions (ROLE, permission)
    VALUES 
    ('app.owner', 'organisations.update'),
    ('app.owner', 'organisations.delete'),
    ('app.owner', 'users.admin'),
--     ('app.owner', 'users.update'), -- don't need update if admin is set
--     ('app.owner', 'users.delete'), -- don't need delete if admin is set
    ('app.admin', 'organisations.update'),
    ('app.admin', 'organisations.delete'),
    ('app.admin', 'users.admin'),
    ('org.owner', 'organisations.update'),
    ('org.owner', 'users.admin'),
    ('org.admin', 'users.admin');


SET check_function_bodies = OFF;

--
-- public.get_auth_userid_by_email (email text)
--
CREATE OR REPLACE FUNCTION public.get_auth_userid_by_email (email text)
    RETURNS uuid
    AS $$
DECLARE
    user_id uuid;
BEGIN
    SELECT
        id INTO user_id
    FROM
        auth.users
    WHERE
        auth.users.email = get_auth_userid_by_email.email;
    RETURN user_id;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER;

ALTER FUNCTION public.get_auth_userid_by_email (email text) OWNER TO postgres;

--
-- authorize with role-based access control (RBAC)
--
-- CREATE FUNCTION public.user_has_permission(auth_id uuid, requested_permission public.app_permission)
--     RETURNS boolean
--     AS $$
-- DECLARE
--     bind_permissions int;
-- BEGIN
--     EXECUTE (
--         SELECT
--             count(*)
--         FROM
--             public.role_permissions
--             INNER JOIN public.user_roles ON public.role_permissions.role = public.user_roles.role
--             INNER JOIN public.users ON public.user_roles.user_id = public.users.id
--         WHERE (public.role_permissions.permission = $1
--             OR public.user_roles.role = 'org.owner')
--         AND public.users.auth_id = $2) INTO bind_permissions
-- 	USING requested_permission, auth_id;
-- 	RETURN bind_permissions > 0;
-- END;
-- $$
-- LANGUAGE plpgsql
-- SECURITY DEFINER;



CREATE FUNCTION public.user_has_permission(auth_id uuid, requested_permission public.app_permission)
    RETURNS boolean
    AS $$
DECLARE
    bind_permissions int;
    query_text text;
BEGIN
	query_text := '
		SELECT count(*)
		FROM public.role_permissions
		INNER JOIN public.user_roles ON public.role_permissions.role = public.user_roles.role
		INNER JOIN public.users ON public.user_roles.user_id = public.users.id
		WHERE public.role_permissions.permission = $1 AND public.users.auth_id = $2';
    EXECUTE query_text INTO bind_permissions
    USING requested_permission, auth_id;
    RETURN bind_permissions > 0;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER;

-- CREATE FUNCTION public.user_has_permission(auth_id uuid, requested_permission public.app_permission)
--     RETURNS boolean
--     AS $$
-- DECLARE
--     bind_permissions int;
--     query_text text;
-- BEGIN
--     IF position('org.' IN requested_permission::text) = 1 THEN
--         query_text := '
--             SELECT count(*)
--             FROM public.role_permissions
--             INNER JOIN public.user_roles ON public.role_permissions.role = public.user_roles.role
--             INNER JOIN public.users ON public.user_roles.user_id = public.users.id
--             INNER JOIN public.organisations ON public.users.organisation_id = public.organisations.id
--             WHERE public.role_permissions.permission = $1 AND public.users.auth_id = $2';
--     ELSE
--         query_text := '
--             SELECT count(*)
--             FROM public.role_permissions
--             INNER JOIN public.user_roles ON public.role_permissions.role = public.user_roles.role
--             INNER JOIN public.users ON public.user_roles.user_id = public.users.id
--             WHERE public.role_permissions.permission = $1 AND public.users.auth_id = $2';
--     END IF;
--     EXECUTE query_text INTO bind_permissions
--     USING requested_permission, auth_id;
--     RETURN bind_permissions > 0;
-- END;
-- $$
-- LANGUAGE plpgsql
-- SECURITY DEFINER;


ALTER FUNCTION public.user_has_permission(auth_id uuid, requested_permission public.app_permission) OWNER TO postgres;

--
-- inserts a row into public.users and assigns roles
--
CREATE FUNCTION public.handle_new_auth_user()
    RETURNS TRIGGER
    AS $$
DECLARE
    new_user_id bigint;  -- Variable to store the newly generated user id
    organisation_id bigint;  -- Variable to store the organisations.id::bigint from organisations table
    org_uuid uuid;  -- Variable to store the organisation_id::uuid from raw_user_meta_data
    is_first_user boolean;  -- Variable to store if this is the first user for the org
    is_admin boolean;  -- Variable to store is_admin from raw_user_meta_data
    is_moderator boolean;  -- Variable to store is_moderator from raw_user_meta_data
BEGIN
    -- Insert a new user and get the new user id
    INSERT INTO public.users (auth_id, username, email)
        VALUES (NEW.id, NEW.email, NEW.email)
        RETURNING id INTO new_user_id;  -- Store the new id into new_user_id

    -- Get organisation_id from raw_user_meta_data JSONB field
    -- SELECT (NEW.raw_user_meta_data ->> 'organisation_id')::bigint INTO organisation_id;
    SELECT (NEW.raw_user_meta_data ->> 'organisation_id')::uuid INTO org_uuid;
    SELECT id FROM public.organisations WHERE public.organisations.org_id = org_uuid INTO organisation_id;

    -- Now, you can use new_user_id and organisation_id in subsequent statements
    -- For example, inserting into organisation_users table
    INSERT INTO public.organisation_users (organisation_id, user_id, is_primary_org)
        VALUES (organisation_id, new_user_id, true);

    -- Get is_admin and is_moderator from raw_user_meta_data JSONB field
    SELECT (NEW.raw_user_meta_data ->> 'is_admin')::boolean INTO is_admin;
    SELECT (NEW.raw_user_meta_data ->> 'is_moderator')::boolean INTO is_moderator;

    -- Check if this is the first user
	SELECT count(*) = 1 FROM auth.users WHERE (raw_user_meta_data ->> 'organisation_id')::uuid = org_uuid INTO is_first_user;

    -- Your updated logic for roles based on raw_user_meta_data and is_first_user
    IF is_first_user THEN
        INSERT INTO public.user_roles (user_id, role)
            VALUES (new_user_id, 'org.owner');
    END IF;

    IF is_admin OR is_first_user THEN
        INSERT INTO public.user_roles (user_id, role)
            VALUES (new_user_id, 'org.admin');
    END IF;

    IF is_moderator OR is_first_user THEN
        INSERT INTO public.user_roles (user_id, role)
            VALUES (new_user_id, 'org.moderator');
    END IF;

    RETURN NEW;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER;


ALTER FUNCTION public.handle_new_auth_user() OWNER TO postgres;

--
-- Name: match_person_sections(extensions.vector, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--
CREATE FUNCTION public.match_person_sections (embedding extensions.vector, match_threshold double precision, match_count integer, min_content_length integer)
    RETURNS TABLE (
        username text,
        content text,
        similarity double precision)
    LANGUAGE plpgsql
    AS $$
    # variable_conflict use_variable
BEGIN
    RETURN query
    SELECT
        persons.username,
        person_sections.content,
        (person_sections.embedding < #> embedding) * -1 AS similarity
    FROM
        person_sections
        JOIN persons ON person_sections.person_id = persons.id
        -- We only care about sections that have a useful amount of content
    WHERE
        length(person_sections.content) >= min_content_length
        -- The dot product is negative because of a Postgres limitation, so we negate it
        AND (person_sections.embedding < #> embedding) * -1 > match_threshold
        -- OpenAI embeddings are normalized to length 1, so
        -- cosine similarity and dot product will produce the same results.
        -- Using dot product which can be computed slightly faster.
        --
        -- For the different syntaxes, see https://github.com/pgvector/pgvector
    ORDER BY
        person_sections.embedding < #> embedding
    LIMIT match_count;
END;
$$;

ALTER FUNCTION public.match_person_sections (embedding extensions.vector, match_threshold double precision, match_count integer, min_content_length integer) OWNER TO postgres;



CREATE FUNCTION public.update_updated_at_column()
    RETURNS TRIGGER
    AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$
LANGUAGE plpgsql;

ALTER FUNCTION public.update_updated_at_column() OWNER TO postgres;

CREATE TRIGGER update_org_updated_at
    BEFORE INSERT OR UPDATE ON public.organisations
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_updated_at
    BEFORE INSERT OR UPDATE ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

-- trigger the function every time a user is created
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_auth_user();



CREATE OR REPLACE FUNCTION public.update_user_status()
    RETURNS TRIGGER
    AS $$
BEGIN
    -- Check if status IS 'NEW' and deleted_at is null
    IF NEW.status = 'NEW' AND NEW.deleted_at IS NULL THEN
        NEW.status := 'ACTIVE';
END IF;
    RETURN NEW;
END;
$$
LANGUAGE plpgsql;

ALTER FUNCTION public.update_user_status() OWNER TO postgres;

CREATE TRIGGER update_user_status_trigger
    BEFORE UPDATE ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION public.update_user_status();


SET check_function_bodies = ON;



-- Secure the tables
ALTER TABLE public.organisations ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.organisation_users ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

-- CREATE POLICY "Allow logged-in read access" ON public.organisations
--     FOR SELECT
--         USING (auth.role() = 'authenticated'::text);
CREATE POLICY "Allow individual read access" ON public.organisations
    FOR SELECT
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.organisation_users ON public.users.id = public.organisation_users.user_id
            WHERE
                public.organisation_users.organisation_id = public.organisations.id AND auth.uid() = public.users.auth_id)
                OR public.user_has_permission(auth.uid(), 'organisations.admin')
                OR public.user_has_permission(auth.uid(), 'organisations.read'));



CREATE POLICY "Allow individual insert access" ON public.organisations
    FOR INSERT
        WITH CHECK (TRUE);

-- CREATE POLICY "Allow logged-in read access" ON public.users
--     FOR SELECT
--         USING (auth.role() = 'authenticated'::text);
CREATE POLICY "Allow individual or authorized read access" ON public.users
    FOR SELECT
        USING (auth.uid() = auth_id
                OR public.user_has_permission(auth.uid(), 'users.admin'));


CREATE POLICY "Allow individual insert access" ON public.users
    FOR INSERT
        WITH CHECK (auth.uid() = auth_id);

CREATE POLICY "Allow individual update access" ON public.users
    FOR UPDATE
        USING (auth.uid() = auth_id);


CREATE POLICY "Allow authorized update access" ON public.users
    FOR UPDATE
        USING (auth_id = auth.uid()
            OR public.user_has_permission(auth.uid(), 'users.admin')
            OR public.user_has_permission(auth.uid(), 'users.update'));


CREATE POLICY "Allow authorized delete access" ON public.users
    FOR DELETE
        USING (auth_id = auth.uid()
            OR public.user_has_permission(auth.uid(), 'users.admin')
            OR public.user_has_permission(auth.uid(), 'users.delete'));


CREATE POLICY "Allow individual read access" ON public.organisation_users
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM public.users
            WHERE public.users.id = public.organisation_users.user_id AND auth.uid() = public.users.auth_id
        )
    );

CREATE POLICY "Allow individual read access" ON public.user_roles
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM public.users
            WHERE public.users.id = public.user_roles.user_id AND auth.uid() = public.users.auth_id
        )
    );


CREATE POLICY "Allow logged-in read access" ON public.role_permissions
    FOR SELECT
        USING (auth.role() = 'authenticated');



-- Send "previous data" on change
ALTER TABLE public.organisations REPLICA IDENTITY
    FULL;

ALTER TABLE public.users REPLICA IDENTITY
    FULL;

-- add tables to the publication
ALTER publication supabase_realtime
    ADD TABLE public.organisations;

ALTER publication supabase_realtime
    ADD TABLE public.users;

