CREATE SEQUENCE public.embeddings_id_seq;

-- Base embeddings table
CREATE TABLE public.embeddings (
    id bigint DEFAULT nextval('public.embeddings_id_seq') NOT NULL,
    group_id bigint,
    group_order integer,
    content text,
    token_count integer,
    created_by bigint REFERENCES public.users NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone
);

COMMENT ON TABLE public.embeddings IS 'Embedding data parent table, see sub-tables for vectors.';
COMMENT ON COLUMN public.embeddings.group_id IS 'If token_count is too large, the content must be split and we get multiple embeddings. The additional embeddings will have group_id set to id of first embedding in the group.';
COMMENT ON COLUMN public.embeddings.group_order IS 'If there is a group of embeddings, group_order specifies the order they were created.';

ALTER TABLE public.embeddings OWNER TO postgres;


--
-- Name: embeddings_ada_002; Type: TABLE; Schema: public; Owner: postgres
--
-- Specialized table for OpenAI embeddings
CREATE TABLE public.embeddings_ada_002 (
    embedding extensions.vector (1536)
)
INHERITS (public.embeddings);
COMMENT ON TABLE public.embeddings_ada_002 IS 'Embedding data, using ada_002.';
ALTER TABLE public.embeddings_ada_002 OWNER TO postgres;
ALTER TABLE public.embeddings_ada_002
    ALTER COLUMN id SET DEFAULT nextval('public.embeddings_id_seq');


--
-- Name: embeddings_gte_small; Type: TABLE; Schema: public; Owner: postgres
--
-- Specialized table for GTE-Small embeddings
CREATE TABLE public.embeddings_gte_small (
    embedding extensions.vector (384)
)
INHERITS (public.embeddings);
COMMENT ON TABLE public.embeddings_gte_small IS 'Embedding data, using gte_small.';
ALTER TABLE public.embeddings_gte_small OWNER TO postgres;
ALTER TABLE public.embeddings_gte_small 
    ALTER COLUMN id SET DEFAULT nextval('public.embeddings_id_seq');



--
-- Name: persons; Type: TABLE; Schema: public; Owner: postgres
--
CREATE TABLE public.persons (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     organisation_id bigint REFERENCES public.organisations ON DELETE CASCADE NOT NULL,
    user_id bigint REFERENCES public.users ON DELETE CASCADE NOT NULL,
    name varchar(255) NOT NULL,
    email varchar(255) UNIQUE NOT NULL,
    location text,
    bio text,
    person_data jsonb,
    created_by bigint REFERENCES public.users NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone
);
COMMENT ON TABLE public.persons IS 'Persons for matching.';
ALTER TABLE public.persons OWNER TO postgres;



-- Specialized table for OpenAI embeddings for persons
CREATE TABLE public.person_embeddings_ada_002 (
    person_id bigint REFERENCES public.persons (id) ON DELETE CASCADE
)
INHERITS (public.embeddings_ada_002);
COMMENT ON TABLE public.person_embeddings_ada_002 IS 'Embedding data for persons, using ada_002 - Sub-table to link embedding data to persons - parent table.';
ALTER TABLE public.person_embeddings_ada_002 OWNER TO postgres;
ALTER TABLE public.person_embeddings_ada_002
    ALTER COLUMN id SET DEFAULT nextval('public.embeddings_id_seq');
CREATE INDEX idx_person_embeddings_ada_002 ON public.person_embeddings_ada_002(person_id);


-- Specialized table for GTE-Small embeddings for persons
CREATE TABLE public.person_embeddings_gte_small (
    person_id bigint REFERENCES public.persons (id) ON DELETE CASCADE
)
INHERITS (public.embeddings_gte_small);
COMMENT ON TABLE public.person_embeddings_gte_small IS 'Embedding data for persons, using gte_small - Sub-table to link embedding data to persons - parent table.';
ALTER TABLE public.person_embeddings_gte_small OWNER TO postgres;
ALTER TABLE public.person_embeddings_gte_small 
    ALTER COLUMN id SET DEFAULT nextval('public.embeddings_id_seq');
CREATE INDEX idx_person_embeddings_gte_small ON public.person_embeddings_gte_small(person_id);







-- CATEGORIES
CREATE TABLE public.categories (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organisation_id bigint REFERENCES public.organisations ON DELETE CASCADE NOT NULL,
    slug text NOT NULL UNIQUE,
    created_by bigint REFERENCES public.users NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone
);

COMMENT ON TABLE public.categories IS 'Topics and groups.';

ALTER TABLE public.categories OWNER TO postgres;


-- MESSAGES
CREATE TABLE public.messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    person_id bigint REFERENCES public.persons NOT NULL,
    category_id bigint REFERENCES public.categories ON DELETE CASCADE NOT NULL,
    message text,
    created_by bigint REFERENCES public.users NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone
);

COMMENT ON TABLE public.messages IS 'Individual messages sent by each user.';

ALTER TABLE public.messages OWNER TO postgres;




-- Specialized table for OpenAI embeddings for messages
CREATE TABLE public.message_embeddings_ada_002 (
    message_id bigint REFERENCES public.messages (id) ON DELETE CASCADE
)
INHERITS (public.embeddings_ada_002);
COMMENT ON TABLE public.message_embeddings_ada_002 IS 'Embedding data for messages, using ada_002 - Sub-table to link embedding data to messages - parent table.';
ALTER TABLE public.message_embeddings_ada_002 OWNER TO postgres;
ALTER TABLE public.message_embeddings_ada_002
    ALTER COLUMN id SET DEFAULT nextval('public.embeddings_id_seq');
CREATE INDEX idx_message_embeddings_ada_002 ON public.message_embeddings_ada_002(message_id);


-- Specialized table for GTE-Small embeddings for messages
CREATE TABLE public.message_embeddings_gte_small (
    message_id bigint REFERENCES public.messages (id) ON DELETE CASCADE
)
INHERITS (public.embeddings_gte_small);
COMMENT ON TABLE public.message_embeddings_gte_small IS 'Embedding data for messages, using gte_small - Sub-table to link embedding data to messages - parent table.';
ALTER TABLE public.message_embeddings_gte_small OWNER TO postgres;
ALTER TABLE public.message_embeddings_gte_small 
    ALTER COLUMN id SET DEFAULT nextval('public.embeddings_id_seq');
CREATE INDEX idx_message_embeddings_gte_small ON public.message_embeddings_gte_small(message_id);




-- 
-- -- Create table for docs
-- CREATE TABLE docs (
--     id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     title varchar(255) NOT NULL,
--     content text NOT NULL,
--     created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
--     updated_at timestamp with time zone
-- );
-- 
-- -- Create specialized table for docs_embeddings inheriting from embeddings
-- CREATE TABLE docs_embeddings (
--     doc_id bigint REFERENCES docs (id) ON DELETE CASCADE
-- )
-- INHERITS (
--     embeddings
-- );
-- 
-- -- Create table for chats
-- CREATE TABLE chats (
--     id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     participants jsonb NOT NULL,
--     created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
--     updated_at timestamp with time zone
-- );
-- 
-- -- Create specialized table for chats_embeddings inheriting from embeddings
-- CREATE TABLE chats_embeddings (
--     chat_id bigint REFERENCES chats (id) ON DELETE CASCADE
-- )
-- INHERITS (
--     embeddings
-- );
-- 
-- -- Create indices for faster look-up
-- CREATE INDEX idx_docs_embeddings ON docs_embeddings (chat_id);
-- 
-- CREATE INDEX idx_chats_embeddings ON chats_embeddings (chat_id);
-- 







--
-- inserts a row into public.persons
--
CREATE FUNCTION public.handle_new_user()
    RETURNS TRIGGER
    AS $$
DECLARE
    new_person_id bigint;  -- Variable to store the newly generated user id
    auth_user_id bigint;
BEGIN
	SELECT u.id FROM public.users as u
	WHERE u.auth_id = auth.uid() INTO auth_user_id;

    -- If auth_user_id is still NULL, set it to NEW.id
    IF auth_user_id IS NULL THEN
        auth_user_id := NEW.id;
    END IF;

    -- Insert a new person and get the new person id
    INSERT INTO public.persons (user_id, email, name, created_by)
        VALUES (NEW.id, NEW.email, CONCAT(NEW.name_first, ' ', NEW.name_last), auth_user_id)
        RETURNING id INTO new_person_id;  -- Store the new id into new_person_id

    RETURN NEW;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER;

ALTER FUNCTION public.handle_new_user() OWNER TO postgres;



CREATE FUNCTION public.set_created_by_column()
    RETURNS TRIGGER
    AS $$
DECLARE
    auth_user_id bigint;
BEGIN
    IF NEW.created_by IS NULL THEN
		SELECT u.id FROM public.users as u
		WHERE u.auth_id = auth.uid() INTO auth_user_id;
	
		NEW.created_by = auth_user_id;
    END IF;
    RETURN NEW;
END;
$$
LANGUAGE plpgsql;

ALTER FUNCTION public.set_created_by_column() OWNER TO postgres;


-- trigger the function every time a user is created
CREATE TRIGGER on_user_created
    AFTER INSERT ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();


-- triggers to set created_by
CREATE TRIGGER insert_person_created_by
    BEFORE INSERT ON public.persons
    FOR EACH ROW
    EXECUTE FUNCTION public.set_created_by_column();

CREATE TRIGGER insert_category_created_by
    BEFORE INSERT ON public.categories
    FOR EACH ROW
    EXECUTE FUNCTION public.set_created_by_column();

CREATE TRIGGER insert_message_created_by
    BEFORE INSERT ON public.messages
    FOR EACH ROW
    EXECUTE FUNCTION public.set_created_by_column();


CREATE TRIGGER insert_embedding_created_by
    BEFORE INSERT ON public.embeddings
    FOR EACH ROW
    EXECUTE FUNCTION public.set_created_by_column();


CREATE TRIGGER insert_person_embeddings_ada_002_created_by
    BEFORE INSERT ON public.person_embeddings_ada_002
    FOR EACH ROW
    EXECUTE FUNCTION public.set_created_by_column();
CREATE TRIGGER insert_person_embeddings_gte_small_created_by
    BEFORE INSERT ON public.person_embeddings_gte_small
    FOR EACH ROW
    EXECUTE FUNCTION public.set_created_by_column();

CREATE TRIGGER insert_message_embeddings_ada_002_created_by
    BEFORE INSERT ON public.message_embeddings_ada_002
    FOR EACH ROW
    EXECUTE FUNCTION public.set_created_by_column();
CREATE TRIGGER insert_message_embeddings_gte_small_created_by
    BEFORE INSERT ON public.message_embeddings_gte_small
    FOR EACH ROW
    EXECUTE FUNCTION public.set_created_by_column();


-- triggers to set updated_at


CREATE TRIGGER update_person_updated_at
    BEFORE INSERT OR UPDATE ON public.persons
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_category_updated_at
    BEFORE INSERT OR UPDATE ON public.categories
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_message_updated_at
    BEFORE INSERT OR UPDATE ON public.messages
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_embedding_updated_at
    BEFORE INSERT OR UPDATE ON public.embeddings
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();


CREATE TRIGGER update_person_embeddings_ada_002_updated_at
    BEFORE INSERT ON public.person_embeddings_ada_002
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_person_embeddings_gte_small_updated_at
    BEFORE INSERT ON public.person_embeddings_gte_small
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_message_embeddings_ada_002_updated_at
    BEFORE INSERT ON public.message_embeddings_ada_002
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_message_embeddings_gte_small_updated_at
    BEFORE INSERT ON public.message_embeddings_gte_small
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();



-- Secure the tables
ALTER TABLE public.persons ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.embeddings ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.embeddings_ada_002 ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.embeddings_gte_small ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.person_embeddings_ada_002 ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.person_embeddings_gte_small ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.message_embeddings_ada_002 ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.message_embeddings_gte_small ENABLE ROW LEVEL SECURITY;




-- CREATE POLICY "Allow logged-in read access" ON public.persons
--     FOR SELECT
--         USING (auth.role() = 'authenticated');
CREATE POLICY "Allow individual or authorized read access" ON public.persons
    FOR SELECT
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
            WHERE
                public.users.id = public.persons.user_id AND auth.uid() = public.users.auth_id)
                OR public.user_has_permission(auth.uid(), 'persons.admin')
                OR public.user_has_permission(auth.uid(), 'persons.read'));

CREATE POLICY "Allow individual insert access" ON public.persons
    FOR INSERT
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                public.users AS u
                JOIN public.persons AS p ON u.id = p.user_id
            WHERE
                auth.uid() = u.auth_id));

CREATE POLICY "Allow individual or authorized update access" ON public.persons
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users AS u
                JOIN public.persons AS p ON u.id = p.user_id
            WHERE
                u.auth_id = auth.uid() 
                OR (public.user_has_permission(auth.uid(), 'persons.admin') OR public.user_has_permission(auth.uid(), 'persons.update'))));

CREATE POLICY "Allow individual or authorized delete access" ON public.persons
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
            WHERE
                public.users.id = user_id AND auth.uid() = public.users.auth_id)
                OR public.user_has_permission(auth.uid(), 'persons.admin')
                OR public.user_has_permission(auth.uid(), 'persons.delete'));

------------------------------

-- CREATE POLICY "Allow logged-in read access" ON public.embeddings
--     FOR SELECT
--         USING (user_id = auth.uid()
--         OR public.user_has_permission(auth.uid(), 'embeddings.read'));

CREATE POLICY "Allow logged-in read access" ON public.embeddings
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual insert access" ON public.embeddings
    FOR INSERT
        WITH CHECK (true);

CREATE POLICY "Allow individual or authorized update access" ON public.embeddings
    FOR UPDATE
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual or authorized delete access" ON public.embeddings
    FOR DELETE
        USING (auth.role() = 'authenticated');




CREATE POLICY "Allow logged-in read access" ON public.embeddings_gte_small
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual insert access" ON public.embeddings_gte_small
    FOR INSERT
        WITH CHECK (true);

CREATE POLICY "Allow individual or authorized update access" ON public.embeddings_gte_small
    FOR UPDATE
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual or authorized delete access" ON public.embeddings_gte_small
    FOR DELETE
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow logged-in read access" ON public.embeddings_ada_002
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual insert access" ON public.embeddings_ada_002
    FOR INSERT
        WITH CHECK (true);

CREATE POLICY "Allow individual or authorized update access" ON public.embeddings_ada_002
    FOR UPDATE
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual or authorized delete access" ON public.embeddings_ada_002
    FOR DELETE
        USING (auth.role() = 'authenticated');




CREATE POLICY "Allow individual or authorized read access" ON public.person_embeddings_gte_small
    FOR SELECT
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
            WHERE (public.persons.id = person_id AND auth.uid() = public.users.auth_id))
            OR public.user_has_permission(auth.uid(), 'embeddings.admin')
            OR public.user_has_permission(auth.uid(), 'embeddings.read'));

CREATE POLICY "Allow individual or authorized read access" ON public.person_embeddings_ada_002
    FOR SELECT
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
            WHERE (public.persons.id = person_id AND auth.uid() = public.users.auth_id))
            OR public.user_has_permission(auth.uid(), 'embeddings.admin')
            OR public.user_has_permission(auth.uid(), 'embeddings.read'));


CREATE POLICY "Allow logged-in read access" ON public.person_embeddings_gte_small
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow logged-in read access" ON public.person_embeddings_ada_002
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual insert access" ON public.person_embeddings_gte_small
    FOR INSERT
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                public.users AS u
            WHERE
                auth.uid() = u.auth_id));

CREATE POLICY "Allow individual insert access" ON public.person_embeddings_ada_002
    FOR INSERT
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                public.users AS u
            WHERE
                auth.uid() = u.auth_id));

CREATE POLICY "Allow individual or authorized update access" ON public.person_embeddings_gte_small
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
            WHERE (public.persons.id = public.person_embeddings_gte_small.person_id AND auth.uid() = public.users.auth_id))
            OR (public.user_has_permission(auth.uid(), 'embeddings.admin') OR public.user_has_permission(auth.uid(), 'embeddings.update')));

CREATE POLICY "Allow individual or authorized update access" ON public.person_embeddings_ada_002
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
            WHERE (public.persons.id = public.person_embeddings_ada_002.person_id AND auth.uid() = public.users.auth_id))
            OR (public.user_has_permission(auth.uid(), 'embeddings.admin') OR public.user_has_permission(auth.uid(), 'embeddings.update')));

CREATE POLICY "Allow individual or authorized delete access" ON public.person_embeddings_gte_small
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
            WHERE (public.persons.id = public.person_embeddings_gte_small.person_id AND auth.uid() = public.users.auth_id))
            OR (public.user_has_permission(auth.uid(), 'embeddings.admin') OR public.user_has_permission(auth.uid(), 'embeddings.delete')));

CREATE POLICY "Allow individual or authorized delete access" ON public.person_embeddings_ada_002
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
            WHERE (public.persons.id = public.person_embeddings_ada_002.person_id AND auth.uid() = public.users.auth_id))
            OR (public.user_has_permission(auth.uid(), 'embeddings.admin') OR public.user_has_permission(auth.uid(), 'embeddings.delete')));




-- message embeddings

CREATE POLICY "Allow individual or authorized read access" ON public.message_embeddings_gte_small
    FOR SELECT
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
                JOIN public.messages ON public.persons.id = public.messages.person_id
            WHERE (public.messages.id = message_id AND auth.uid() = public.users.auth_id))
            OR public.user_has_permission(auth.uid(), 'embeddings.admin')
            OR public.user_has_permission(auth.uid(), 'embeddings.read'));

CREATE POLICY "Allow individual or authorized read access" ON public.message_embeddings_ada_002
    FOR SELECT
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
                JOIN public.messages ON public.persons.id = public.messages.person_id
            WHERE (public.messages.id = message_id AND auth.uid() = public.users.auth_id))
            OR public.user_has_permission(auth.uid(), 'embeddings.admin')
            OR public.user_has_permission(auth.uid(), 'embeddings.read'));


CREATE POLICY "Allow logged-in read access" ON public.message_embeddings_gte_small
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow logged-in read access" ON public.message_embeddings_ada_002
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual insert access" ON public.message_embeddings_gte_small
    FOR INSERT
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                public.users AS u
            WHERE
                auth.uid() = u.auth_id));

CREATE POLICY "Allow individual insert access" ON public.message_embeddings_ada_002
    FOR INSERT
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                public.users AS u
            WHERE
                auth.uid() = u.auth_id));

CREATE POLICY "Allow individual or authorized update access" ON public.message_embeddings_gte_small
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
                JOIN public.messages ON public.persons.id = public.messages.person_id
            WHERE (public.messages.id = public.message_embeddings_gte_small.message_id AND auth.uid() = public.users.auth_id))
            OR (public.user_has_permission(auth.uid(), 'embeddings.admin') OR public.user_has_permission(auth.uid(), 'embeddings.update')));

CREATE POLICY "Allow individual or authorized update access" ON public.message_embeddings_ada_002
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
                JOIN public.messages ON public.persons.id = public.messages.person_id
            WHERE (public.messages.id = public.message_embeddings_ada_002.message_id AND auth.uid() = public.users.auth_id))
            OR (public.user_has_permission(auth.uid(), 'embeddings.admin') OR public.user_has_permission(auth.uid(), 'embeddings.update')));

CREATE POLICY "Allow individual or authorized delete access" ON public.message_embeddings_gte_small
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
                JOIN public.messages ON public.persons.id = public.messages.person_id
            WHERE (public.messages.id = public.message_embeddings_gte_small.message_id AND auth.uid() = public.users.auth_id))
            OR (public.user_has_permission(auth.uid(), 'embeddings.admin') OR public.user_has_permission(auth.uid(), 'embeddings.delete')));

CREATE POLICY "Allow individual or authorized delete access" ON public.message_embeddings_ada_002
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
                JOIN public.persons ON public.users.id = public.persons.user_id
                JOIN public.messages ON public.persons.id = public.messages.person_id
            WHERE (public.messages.id = public.message_embeddings_ada_002.message_id AND auth.uid() = public.users.auth_id))
            OR (public.user_has_permission(auth.uid(), 'embeddings.admin') OR public.user_has_permission(auth.uid(), 'embeddings.delete')));






CREATE POLICY "Allow logged-in read access" ON public.categories
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual insert access" ON public.categories
    FOR INSERT
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                public.users
            WHERE
                public.users.id = public.categories.created_by AND auth.uid() = public.users.auth_id));
-- create policy "Allow authorized insert access" on public.categories for insert using ( public.user_has_permission(auth.uid(, 'categories.create')) );

CREATE POLICY "Allow individual or authorized update access" ON public.categories
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
            WHERE
                public.users.id = public.categories.created_by AND auth.uid() = public.users.auth_id)
                OR public.user_has_permission(auth.uid(), 'categories.update'));

CREATE POLICY "Allow individual or authorized delete access" ON public.categories
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
            WHERE
                public.users.id = public.categories.created_by AND auth.uid() = public.users.auth_id)
                OR public.user_has_permission(auth.uid(), 'categories.delete'));



-- TODO - refactor policies for messages to match the refactor done for categories
CREATE POLICY "Allow logged-in read access" ON public.messages
    FOR SELECT
        USING (auth.role() = 'authenticated');

CREATE POLICY "Allow individual insert access" ON public.messages
    FOR INSERT
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                public.users
            WHERE
                public.users.id = public.messages.created_by AND auth.uid() = public.users.auth_id));

CREATE POLICY "Allow individual update access" ON public.messages
    FOR UPDATE
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                public.users
            WHERE
                public.users.id = public.messages.created_by AND auth.uid() = public.users.auth_id));

CREATE POLICY "Allow individual delete access" ON public.messages
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users
            WHERE
                public.users.id = public.messages.created_by AND auth.uid() = public.users.auth_id));

CREATE POLICY "Allow authorized update access" ON public.messages
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users AS u
            WHERE
                u.auth_id = auth.uid() AND public.user_has_permission(auth.uid(), 'messages.update')));

CREATE POLICY "Allow authorized delete access" ON public.messages
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                public.users AS u
            WHERE
                u.auth_id = auth.uid() AND public.user_has_permission(auth.uid(), 'messages.delete')));


-- Send "previous data" on change
ALTER TABLE public.categories REPLICA IDENTITY
    FULL;

ALTER TABLE public.messages REPLICA IDENTITY
    FULL;


/**
 * REALTIME SUBSCRIPTIONS
 * Only allow realtime listening on public tables.
 */
-- BEGIN;
-- -- remove the realtime publication
-- DROP publication IF EXISTS supabase_realtime;
-- -- re-create the publication but don't enable it for any tables
-- CREATE publication supabase_realtime;
-- COMMIT;

-- add tables to the publication
ALTER publication supabase_realtime
    ADD TABLE public.categories;

ALTER publication supabase_realtime
    ADD TABLE public.messages;

