CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "extensions";

CREATE SCHEMA jobs;

CREATE TYPE jobs.job_status AS enum(
    'PENDING',
    'IN_PROGRESS',
    'COMPLETED',
    'ERROR'
);

--
-- Name: job_queue; Type: TABLE; Schema: jobs; Owner: postgres
--
CREATE TABLE jobs.job_queue(
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organisation_id bigint REFERENCES public.organisations ON DELETE CASCADE NOT NULL,
    task text,
    payload jsonb,
    job_results jsonb,
    status jobs.job_status DEFAULT 'PENDING' ::jobs.job_status,
    started_at timestamp with time zone,
    finished_at timestamp with time zone,
    stale_after_seconds integer DEFAULT NULL,
    retry_count integer DEFAULT 0,
    created_by bigint REFERENCES public.users NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone
);

COMMENT ON TABLE jobs.job_queue IS 'Jobs queue.';

ALTER TABLE jobs.job_queue OWNER TO postgres;

CREATE TABLE jobs.job_error_log(
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    job_id bigint REFERENCES jobs.job_queue(id),
    error_message text,
    created_at timestamptz DEFAULT NOW()
);

ALTER TABLE jobs.job_queue OWNER TO postgres;

CREATE FUNCTION jobs.enqueue(payload jsonb)
    RETURNS VOID
    AS $$
BEGIN
    INSERT INTO jobs.job_queue(payload)
        VALUES(payload);
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION jobs.dequeue(max_jobs integer DEFAULT 10)
    RETURNS integer[]
    AS $$
DECLARE
    selected_ids integer[];
BEGIN
    -- Handle timeouts
    UPDATE
        jobs.job_queue
    SET
        status = 'PENDING',
        updated_at = NOW(),
        retry_count = retry_count + 1
    WHERE
        status = 'IN_PROGRESS'
        AND stale_after_seconds IS NOT NULL
        AND NOW() - updated_at >= interval '1 second' * stale_after_seconds;
    -- Dequeue jobs
    UPDATE
        jobs.job_queue
    SET
        status = 'IN_PROGRESS',
        updated_at = NOW()
    WHERE
        id IN (
            SELECT
                id
            FROM
                jobs.job_queue
            WHERE
                status = 'PENDING'
            LIMIT max_jobs
            FOR UPDATE
                SKIP LOCKED)
    RETURNING
        id INTO selected_ids;
    RETURN selected_ids;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION jobs.process_job(job_id integer)
    RETURNS VOID
    AS $$
DECLARE
    job_payload jsonb;
    job_task text;
BEGIN
    BEGIN
        SELECT
            payload,
            task INTO job_payload,
            job_task
        FROM
            jobs.job_queue
        WHERE
            id = job_id;
        -- select
        --     net.http_post(
        --         url:='https://project-ref.supabase.co/functions/v1/function-name',
        --         headers:='{"Content-Type": "application/json", "Authorization": "Bearer YOUR_ANON_KEY"}'::jsonb,
        --         body:='{"name": "pg_net"}'::jsonb
        --     ) as request_id;
        UPDATE
            jobs.job_queue
        SET
            status = 'COMPLETED',
            finished_at = NOW(),
            updated_at = NOW()
        WHERE
            id = job_id;
    EXCEPTION
        WHEN OTHERS THEN
            INSERT INTO jobs.job_error_log(job_id, error_message)
                VALUES (job_id, 'An error occurred during processing: ' || SQLERRM);
    UPDATE
        jobs.job_queue
    SET
        status = 'ERROR',
        updated_at = NOW()
    WHERE
        id = job_id
        AND retry_count >= 3;
    -- Max retries: 3
    UPDATE
        jobs.job_queue
    SET
        status = 'PENDING',
        updated_at = NOW(),
        retry_count = retry_count + 1
    WHERE
        id = job_id
        AND retry_count < 3;
    END;
END;

$$
LANGUAGE plpgsql;

ALTER FUNCTION jobs.process_job(job_id INTEGER) OWNER TO postgres;

CREATE OR REPLACE FUNCTION jobs.run_jobs(max_jobs integer DEFAULT 10)
    RETURNS VOID
    AS $$
DECLARE
    job_ids integer[];
    job_id integer;
BEGIN
    job_ids := jobs.dequeue(max_jobs);
    IF array_length(job_ids, 1) IS NULL THEN
        RETURN;
    END IF;
    FOREACH job_id IN ARRAY job_ids LOOP
        BEGIN
            UPDATE
                jobs.job_queue
            SET
                started_at = NOW()
            WHERE
                id = job_id;
            PERFORM
                jobs.process_job(job_id);
        EXCEPTION
            WHEN OTHERS THEN
                INSERT INTO jobs.job_error_log(job_id, error_message)
                    VALUES (job_id, 'An error occurred during running: ' || SQLERRM);
        UPDATE
            jobs.job_queue
        SET
            status = 'ERROR',
            updated_at = NOW()
        WHERE
            id = job_id
            AND retry_count >= 3;
        -- Max retries: 3
        UPDATE
            jobs.job_queue
        SET
            status = 'PENDING',
            updated_at = NOW(),
            retry_count = retry_count + 1
        WHERE
            id = job_id
            AND retry_count < 3;
        END;
    END LOOP;
END;

$$
LANGUAGE plpgsql;

ALTER FUNCTION jobs.run_jobs(max_jobs integer) OWNER TO postgres;

-- SELECT cron.schedule('Every 1 minute', $$SELECT jobs.run_jobs()$$);
-- SELECT cron.schedule('Every 1 minute', $$SELECT jobs.run_jobs(100)$$); -- run 100 jobs in each batch
